# ARM Cortex-M 芯片上电启动机制详解

本文档详细讲解 ARM Cortex-M 系列芯片（以 STM32F103 为例）从上电到执行 `main()` 函数的完整启动过程。

## 1. 启动过程概览

ARM 芯片的启动过程可以分为两个主要阶段：
1.  **硬件自动加载阶段**：芯片上电复位后，内核自动执行的硬件动作。
2.  **软件初始化阶段**：执行启动文件（Startup File）中的汇编代码，准备 C 语言运行环境。

---

## 2. 硬件自动加载阶段

当芯片上电，电源电压稳定且复位引脚（NRST）电平拉高后，Cortex-M3 内核会按照硬件设计的时序自动执行以下两个动作：

1.  **读取栈顶地址 (MSP)**：
    *   内核从内存地址 `0x0000 0000` 处读取数据，并将其赋值给 **主栈指针 (MSP, Main Stack Pointer)** 寄存器。
    *   这个值通常是 SRAM 的结束地址（栈是向下生长的）。

2.  **读取复位向量 (PC)**：
    *   内核从内存地址 `0x0000 0004` 处读取数据，并将其赋值给 **程序计数器 (PC)**。
    *   这个数据是复位中断服务程序（`Reset_Handler`）的入口地址。

**注意**：STM32 内部通过硬件机制将 Flash 映射到 `0x0000 0000` 地址，因此实际上是去读取 Flash 起始位置的前两个字。

---

## 3. 中断向量表 (Interrupt Vector Table)

中断向量表是 ARM Cortex-M 核心处理异常和中断的关键入口。它是一个存储在内存起始位置（通常是 Flash 的 0 地址）的 32 位地址数组。

### 3.1 向量表结构
向量表中存放的是各个**异常服务程序（ISR）的入口地址**。当异常或中断发生时，硬件会自动从表中查找到对应的函数地址并跳转执行。

| 偏移地址 | 向量名称 | 类型 | 说明 |
| :--- | :--- | :--- | :--- |
| `0x0000 0000` | **__initial_sp** | 核心 | 初始栈顶地址 (MSP)，**唯一不是地址的数据** |
| `0x0000 0004` | **Reset_Handler** | 核心 | 复位处理程序入口，程序执行的第一条指令 |
| `0x0000 0008` | **NMI_Handler** | 核心 | 不可屏蔽中断 |
| `0x0000 000C` | **HardFault_Handler** | 核心 | 硬件错误（如非法内存访问、总线错误） |
| `...` | ... | ... | ... |
| `0x0000 003C` | **SysTick_Handler** | 核心 | 系统滴答定时器（常用于 RTOS 调度） |
| `0x0000 0040` | **WWDG_IRQHandler** | 外设 | 窗口看门狗中断 |
| `...` | ... | ... | ... |
| `0x0000 00D4` | **USART1_IRQHandler** | 外设 | 串口 1 全局中断 |

### 3.2 向量表重映射 (Vector Table Remapping)
虽然 Cortex-M3 默认从 `0x0000 0000` 获取向量表，但在 STM32 中，Flash 实际物理地址是 `0x0800 0000`。
*   **启动时**：硬件通过**内存映射**（Memory Map）机制将 Flash 别名映射到 0 地址，因此 CPU 上电能读取到 Flash 开头的内容。
*   **运行时**：用户可以通过修改 `SCB->VTOR` (向量表偏移寄存器) 来重定位向量表。
    *   **应用场景**：在使用 Bootloader + App 架构时，App 程序的向量表通常位于 `0x0800 5000` 等偏移地址。App 启动的第一步必须修改 `VTOR` 指向该地址，否则产生中断时，CPU 仍会跳转到旧的（Bootloader 的）中断服务程序，导致程序崩溃。

---

## 4. 软件初始化阶段 (Reset_Handler)

一旦 PC 指针被加载了 `Reset_Handler` 的地址，CPU 就开始跳转执行该汇编函数。这是软件启动的第一步。

典型的 `Reset_Handler` 流程如下（参考 `startup_stm32f10x_md.s`）：

### 4.1 设置时钟系统 (SystemInit)
*   **指令**：`BL SystemInit`
*   **作用**：调用 C 语言编写的 `SystemInit` 函数（位于 `system_stm32f10x.c`）。
*   **细节**：
    *   复位 RCC（复位和时钟控制）寄存器。
    *   开启 HSE（外部高速时钟）。
    *   配置 PLL（锁相环）倍频，将系统时钟（SYSCLK）设置为 72MHz。
    *   配置 AHB、APB 总线时钟。

### 4.2 初始化 C 运行环境 (__main)
*   **指令**：`BL __main` (注意：这是 C 库提供的入口，不是用户的 `main`)
*   **作用**：由编译器提供的 C 运行时库完成内存布局的初始化。
*   **关键步骤**：
    1.  **复制数据段 (.data)**：将已初始化的全局变量和静态变量从 Flash（LMA，加载地址）复制到 RAM（VMA，运行地址）。
    2.  **清零 BSS 段 (.bss)**：将未初始化的全局变量和静态变量所在的 RAM 区域清零（赋值为 0）。
    3.  **初始化堆栈**：如果有使用堆（Heap），也会在此初始化。

### 4.3 跳转到用户主函数 (main)
*   **指令**：`BL main`
*   **作用**：当 C 环境准备就绪后，跳转到用户编写的 `int main(void)` 函数。
*   此时，全局变量已生效，时钟已就绪，程序开始执行业务逻辑。

---

## 5. 内存分布示意图

```text
地址空间 (4GB)
+------------------+ 0xFFFFFFFF
|                  |
|   外设寄存器      |
|                  |
+------------------+ 0x40000000
|                  |
|   SRAM (RAM)     | <--- 变量 (.data, .bss), 栈 (Stack), 堆 (Heap)
|  (0x20000000起)  |
+------------------+
|                  |
|   Flash (ROM)    | <--- 代码 (.text), 常量 (.rodata), 初始数据值
|  (0x08000000起)  |
+------------------+ 0x00000000 (重映射后)
```

## 6. 启动代码示例 (汇编)

```assembly
; 向量表定义
__Vectors       DCD     __initial_sp               ; Top of Stack (0x00)
                DCD     Reset_Handler              ; Reset Handler (0x04)
                DCD     NMI_Handler                ; NMI Handler
                ; ...

; 复位处理程序
Reset_Handler   PROC
                EXPORT  Reset_Handler             [WEAK]
                IMPORT  __main
                IMPORT  SystemInit

                LDR     R0, =SystemInit
                BLX     R0                        ; 1. 初始化时钟

                LDR     R0, =__main
                BX      R0                        ; 2. 初始化C库并跳转到main
                ENDP
```

## 7. 总结

ARM 芯片的启动是一个“硬件搭台，软件唱戏”的过程：
1.  **硬件** 负责把 PC 指针指到正确的位置（Reset_Handler）。
2.  **向量表** 提供了所有异常处理的入口地图。
3.  **启动文件** 负责配置时钟、搬运数据、清空 BSS。
4.  **main 函数** 开始执行用户逻辑。

理解这个过程对于调试“程序跑飞”、“全局变量初值不对”、“死机”等问题至关重要。
