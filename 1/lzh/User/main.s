;==============================================================================
; STM32F103C8 LED控制汇编程序
; 功能：控制PC13引脚的LED闪烁
; 日期：2025
;==============================================================================

;------------------------------------------------------------------------------
; 寄存器地址定义
;------------------------------------------------------------------------------
RCC_APB2ENR         EQU     0x40021018      ; RCC APB2外设时钟使能寄存器
GPIOC_CRH           EQU     0x40011004      ; GPIOC配置寄存器高位(控制引脚8-15)
GPIOC_ODR           EQU     0x4001100C      ; GPIOC输出数据寄存器
Systick_CTRL        EQU     0xE000E010      ; SysTick控制与状态寄存器
Systick_LOAD        EQU     0xE000E014      ; SysTick加载值寄存器
Systick_VAL         EQU     0xE000E018      ; SysTick当前值寄存器

;------------------------------------------------------------------------------
; 位定义
;------------------------------------------------------------------------------
RCC_APB2ENR_IOPCEN  EQU     0x00000010      ; GPIOC时钟使能位(bit 4)
GPIO_CRH_CNF13      EQU     0x00C00000      ; PC13配置位[23:22]
GPIO_CRH_MODE13     EQU     0x00300000      ; PC13模式位[21:20]
GPIO_ODR_ODR13      EQU     0x00002000      ; PC13输出数据位(bit 13)

;==============================================================================
; 代码段定义
;==============================================================================
                AREA    |.text|, CODE, READONLY
                THUMB                           ; 使用Thumb指令集
                REQUIRE8                        ; 要求8字节对齐
                PRESERVE8                       ; 保持8字节对齐

                EXPORT  __main
				EXPORT  main                    ; 导出main函数
                ENTRY                           ; 程序入口点

;==============================================================================
; 主函数 - LED闪烁控制程序
;==============================================================================
__main
main
                ;--------------------------------------------------------------
                ; 步骤1: 开启GPIOC时钟
                ; RCC->APB2ENR |= RCC_APB2ENR_IOPCEN
                ;--------------------------------------------------------------
                LDR     r0, =RCC_APB2ENR        ; 加载RCC_APB2ENR寄存器地址
                LDR     r1, [r0]                ; 读取当前寄存器值
                LDR     r2, =RCC_APB2ENR_IOPCEN ; 加载GPIOC时钟使能位
                ORR     r1, r1, r2              ; 设置GPIOC时钟使能位
                STR     r1, [r0]                ; 写回寄存器

                ;--------------------------------------------------------------
                ; 步骤2: 配置PC13为推挽输出模式，50MHz
                ; GPIOC->CRH &= ~(GPIO_CRH_CNF13 | GPIO_CRH_MODE13)
                ; GPIOC->CRH |= GPIO_CRH_MODE13 (50MHz输出)
                ;--------------------------------------------------------------
                LDR     r0, =GPIOC_CRH          ; 加载GPIOC_CRH寄存器地址
                LDR     r1, [r0]                ; 读取当前寄存器值
                
                ; 清除PC13的配置位和模式位
                LDR     r2, =GPIO_CRH_CNF13     ; 加载配置位掩码
                LDR     r3, =GPIO_CRH_MODE13    ; 加载模式位掩码
                ORR     r2, r2, r3              ; 合并需要清除的位
                BIC     r1, r1, r2              ; 清除这些位，即r1 = r1 AND (NOT r2)
                
                ; 设置PC13为推挽输出，50MHz (MODE13[1:0] = 11)
                LDR     r2, =GPIO_CRH_MODE13    ; 加载模式位
                ORR     r1, r1, r2              ; 设置模式位为11(50MHz输出)
                STR     r1, [r0]                ; 写回寄存器

;==============================================================================
; 主循环 - LED闪烁控制
;==============================================================================
loop
                ;--------------------------------------------------------------
                ; 点亮LED (设置PC13输出低电平)
                ; GPIOC->ODR &= ~GPIO_ODR_ODR13
                ;--------------------------------------------------------------
                LDR     r0, =GPIOC_ODR          ; 加载GPIOC_ODR寄存器地址
                LDR     r1, [r0]                ; 读取当前寄存器值
                LDR     r2, =GPIO_ODR_ODR13     ; 加载PC13输出位
                BIC     r1, r1, r2              ; 清除PC13位(设置为低电平)
                STR     r1, [r0]                ; 写回寄存器

                ;--------------------------------------------------------------
                ; 延迟500毫秒 (LED点亮持续时间)
                ; 500000微秒 = 500毫秒 = 0.5秒
                ;--------------------------------------------------------------
                BL      delay_ms                ; 调用延迟函数
                
                ;--------------------------------------------------------------
                ; 熄灭LED (设置PC13输出高电平)
                ; GPIOC->ODR |= GPIO_ODR_ODR13
                ;--------------------------------------------------------------
                LDR     r0, =GPIOC_ODR          ; 加载GPIOC_ODR寄存器地址
                LDR     r1, [r0]                ; 读取当前寄存器值
                LDR     r2, =GPIO_ODR_ODR13     ; 加载PC13输出位
                ORR     r1, r1, r2              ; 设置PC13位(设置为高电平)
                STR     r1, [r0]                ; 写回寄存器

                ;--------------------------------------------------------------
                ; 延迟500毫秒 (LED熄灭持续时间)
                ; 500000微秒 = 500毫秒 = 0.5秒
                ; 总闪烁周期：1秒 (0.5秒亮 + 0.5秒灭)
                ;--------------------------------------------------------------
                BL      delay_ms                ; 调用延迟函数
                B       loop                    ; 无条件跳转到loop标签，形成无限循环

;==============================================================================
; 延迟函数 - 使用SysTick定时器实现精确延迟
; 输入参数：r0 = 延迟时间（微秒）
; 功能：基于72MHz系统时钟实现微秒级延迟
;==============================================================================
delay
                ;--------------------------------------------------------------
                ; 计算SysTick加载值
                ; 72MHz时钟下，1微秒需要72个时钟周期
                ; 计算公式：load_value = delay_us * 72
                ;--------------------------------------------------------------
                LSL     r1, r0, #6              ; r1 = r0 * 64 (左移6位)
                LSL     r2, r0, #3              ; r2 = r0 * 8 (左移3位)
                ADD     r1, r1, r2              ; r1 = r0 * 72 (64 + 8 = 72)

                ;--------------------------------------------------------------
                ; 配置SysTick加载寄存器
                ; 设置倒计数初值
                ;--------------------------------------------------------------
                LDR     r2, =Systick_LOAD       ; 加载SysTick加载寄存器地址
                STR     r1, [r2]                ; 写入计算得到的加载值
                
                ;--------------------------------------------------------------
                ; 清零SysTick当前值寄存器
                ; 重置计数器为0，开始新的计数周期
                ;--------------------------------------------------------------
                LDR     r2, =Systick_VAL        ; 加载SysTick当前值寄存器地址
                MOV     r1, #0                  ; 准备清零值
                STR     r1, [r2]                ; 清零当前值寄存器

                ;--------------------------------------------------------------
                ; 启动SysTick定时器
                ; CTRL[2:0] = 101b: 使能定时器 + 使用处理器时钟 + 禁用中断
                ;--------------------------------------------------------------
                LDR     r2, =Systick_CTRL       ; 加载SysTick控制寄存器地址
                MOV     r1, #0x05               ; 0x05 = 101b (使能+处理器时钟+无中断)
                STR     r1, [r2]                ; 启动SysTick定时器

;------------------------------------------------------------------------------
; 延迟循环 - 等待SysTick计数完成
;------------------------------------------------------------------------------
delay_loop
                ;--------------------------------------------------------------
                ; 检查COUNTFLAG位(bit 16)
                ; 当计数器从1减到0时，此位被硬件置1
                ;--------------------------------------------------------------
                LDR     r1, [r2]                ; 读取SysTick控制寄存器
                ANDS    r1, r1, #0x00010000     ; 检查COUNTFLAG位(bit 16)
                BEQ     delay_loop              ; 如果COUNTFLAG=0，继续等待

                ;--------------------------------------------------------------
                ; 关闭SysTick定时器
                ; 保持时钟源设置，但禁用定时器
                ;--------------------------------------------------------------
                LDR     r2, =Systick_CTRL       ; 重新加载控制寄存器地址
                MOV     r1, #0x04               ; 0x04 = 100b (禁用+处理器时钟+无中断)
                STR     r1, [r2]                ; 关闭SysTick定时器

                BX      lr                      ; 返回调用函数

;==============================================================================
; 毫秒延迟函数 - 实现毫秒级延迟
; 功能：延迟500毫秒 (固定延迟时间)
; 实现原理：调用1000次500微秒延迟，总计500毫秒
; 计算：1000 × 500微秒 = 500000微秒 = 500毫秒
; 寄存器使用：r3作为循环计数器，r0作为delay函数参数
;==============================================================================
delay_ms
                ;--------------------------------------------------------------
                ; 保存寄存器状态
                ; 保护r3和lr寄存器，避免函数调用时被破坏
                ;--------------------------------------------------------------
                PUSH    {r3, lr}                ; 将r3和lr压入堆栈保存
                
                ;--------------------------------------------------------------
                ; 初始化循环计数器
                ; 设置循环1000次，每次延迟500微秒
                ;--------------------------------------------------------------
                LDR     r3, =1000               ; r3 = 1000 (循环次数)
                
;------------------------------------------------------------------------------
; 延迟循环 - 执行1000次500微秒延迟
;------------------------------------------------------------------------------
delay_ms_loop
                ;--------------------------------------------------------------
                ; 调用基础延迟函数
                ; 每次延迟500微秒
                ;--------------------------------------------------------------
                LDR     r0, =500                ; r0 = 500微秒 (delay函数参数)
                BL      delay                   ; 调用delay函数，延迟500微秒
                
                ;--------------------------------------------------------------
                ; 更新循环计数器
                ; 递减计数器并检查是否完成所有循环
                ;--------------------------------------------------------------
                SUBS    r3, r3, #1              ; r3 = r3 - 1，同时更新标志位
                BNE     delay_ms_loop           ; 如果r3≠0，继续循环

                ;--------------------------------------------------------------
                ; 恢复寄存器状态并返回
                ; 从堆栈恢复之前保存的寄存器值
                ;--------------------------------------------------------------
                POP     {r3, lr}                ; 从堆栈恢复r3和lr寄存器
                BX      lr                      ; 返回调用函数
;==============================================================================
; 程序结束
;==============================================================================
                ALIGN                           ; 确保代码段对齐
                END